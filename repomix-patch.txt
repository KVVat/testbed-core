File: scripts/setup_tools.sh
#!/bin/bash
# SDK Platform-Toolsを自動インストールするスクリプト (macOS/Linux用)

PLATFORM_TOOLS_DIR="./bin/platform-tools"
OS_TYPE="$(uname -s)"

if [ ! -d "$PLATFORM_TOOLS_DIR" ]; then
    echo "Installing SDK Platform-Tools..."
    mkdir -p bin

    if [ "$OS_TYPE" == "Darwin" ]; then
        URL="https://dl.google.com/android/repository/platform-tools-latest-darwin.zip"
    else
        URL="https://dl.google.com/android/repository/platform-tools-latest-linux.zip"
    fi

    curl -L "$URL" -o bin/tools.zip
    unzip bin/tools.zip -d bin/
    rm bin/tools.zip
    echo "✅ Platform-Tools installed in $PLATFORM_TOOLS_DIR"
else
    echo "✅ Platform-Tools already exists."
fi

File: composeApp/src/jvmMain/kotlin/org/example/project/adb/AdbObserver.kt
package org.example.project.adb

import androidx.lifecycle.viewModelScope
import com.malinskiy.adam.exception.RequestRejectedException
import com.malinskiy.adam.request.logcat.ChanneledLogcatRequest
import com.malinskiy.adam.request.logcat.LogcatReadMode
import com.malinskiy.adam.request.misc.RebootMode
import com.malinskiy.adam.request.misc.RebootRequest
import com.malinskiy.adam.request.shell.v1.ShellCommandRequest
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.currentCoroutineContext
import kotlinx.coroutines.delay
import kotlinx.coroutines.isActive
import kotlinx.coroutines.withContext
import org.example.project.AppViewModel
import org.example.project.LogLevel
import org.example.project.adb.rules.AdbDeviceRule
import java.io.File
import java.time.LocalDateTime
import java.time.format.DateTimeFormatter
import com.malinskiy.adam.request.sync.v1.PullFileRequest
import kotlinx.coroutines.channels.consumeEach
import kotlinx.coroutines.Job
import kotlinx.coroutines.launch
import kotlinx.coroutines.channels.ReceiveChannel

class AdbObserver(private val viewModel: AppViewModel) {

    var adb: AdbDeviceRule = AdbDeviceRule()
    var adbProps: AdbProps = AdbProps()
    private var logcatJob: Job? = null

    /**
     * 依存関係（adbバイナリ）が実行可能かチェックします。
     */
    fun checkDependencies(): Boolean {
        val localAdb = File("bin/platform-tools/adb")
        val isLocalOk = localAdb.exists() && localAdb.canExecute()

        // システムパスのadbも確認
        val isSystemOk = try {
            Runtime.getRuntime().exec("adb --version").waitFor() == 0
        } catch (e: Exception) {
            false
        }

        if (!isLocalOk && !isSystemOk) {
            viewModel.log("SETUP", "Critical Error: 'adb' not found. Please run setup script.", LogLevel.ERROR)
            return false
        }
        return true
    }

    suspend fun captureScreenshot() {
        if (!viewModel.uiState.value.adbIsValid) {
            viewModel.log("ADB", "Cannot take screenshot: No device connected.", LogLevel.ERROR)
            return
        }

        withContext(Dispatchers.IO) {
            try {
                viewModel.log("ADB", "Taking screenshot...", LogLevel.INFO)
                val serial = adb.deviceSerial
                val timestamp = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyyMMdd_HHmmss"))
                val remotePath = "/sdcard/screenshot_tmp.png"

                val localDir = File("screenshots")
                if (!localDir.exists()) localDir.mkdirs()
                val localFile = File(localDir, "screenshot_$timestamp.png")

                adb.adb.execute(ShellCommandRequest("screencap -p $remotePath"), serial)

                val channel = adb.adb.execute(
                    PullFileRequest(remotePath, localFile),
                    this,
                    serial
                )
                for (progress in channel) { }

                adb.adb.execute(ShellCommandRequest("rm $remotePath"), serial)
                viewModel.log("ADB", "Screenshot saved: ${localFile.absolutePath}", LogLevel.PASS)
            } catch (e: Exception) {
                viewModel.log("ADB", "Screenshot failed: ${e.message}", LogLevel.ERROR)
            }
        }
    }

    suspend fun sendText(text: String) {
        if (!viewModel.uiState.value.adbIsValid) return
        if (text.isBlank()) {
            viewModel.log("ADB", "Input ignored: Text is empty.", LogLevel.WARN)
            return
        }
        val hasNonAscii = text.any { it.code > 127 }
        if (hasNonAscii) {
            viewModel.log("ADB", "Input failed: Non-ASCII characters are not supported.", LogLevel.ERROR)
            return
        }

        withContext(Dispatchers.IO) {
            try {
                val escapedText = text.replace(" ", "%s")
                val command = "input text $escapedText"
                val result = adb.adb.execute(ShellCommandRequest(command), adb.deviceSerial)
                if (result.exitCode == 0) {
                    viewModel.log("ADB", "Text sent successfully: $text", LogLevel.PASS)
                } else {
                    viewModel.log("ADB", "Input Failed: ${result.output}", LogLevel.ERROR)
                }
            } catch (e: Exception) {
                viewModel.log("ADB", "Exception sending text: ${e.message}", LogLevel.ERROR)
            }
        }
    }

    suspend fun clearAppData(packageName: String) {
        if (!viewModel.uiState.value.adbIsValid) return
        try {
            val output = adb.adb.execute(ShellCommandRequest("pm clear $packageName"), adb.deviceSerial)
            if (output.output.contains("Success")) {
                viewModel.log("ADB", "Cleared app data for $packageName", LogLevel.INFO)
            }
        } catch (e: Exception) {
            viewModel.log("ADB", "Clear data failed: ${e.message}", LogLevel.ERROR)
        }
    }

    suspend fun rebootToBootloader() {
        if (!viewModel.uiState.value.adbIsValid) return
        withContext(Dispatchers.IO) {
            try {
                adb.adb.execute(RebootRequest(RebootMode.BOOTLOADER), adb.deviceSerial)
                viewModel.log("ADB", "Rebooting to bootloader...", LogLevel.PASS)
            } catch (e: Exception) {
                viewModel.log("ADB", "Reboot failed: ${e.message}", LogLevel.ERROR)
            }
        }
    }

    suspend fun sendKeyEvent(keyCode: Int) {
        if (!viewModel.uiState.value.adbIsValid) return
        withContext(Dispatchers.IO) {
            try {
                adb.adb.execute(ShellCommandRequest("input keyevent $keyCode"), adb.deviceSerial)
            } catch (e: Exception) {
                viewModel.log("ADB", "Key event failed: ${e.message}", LogLevel.ERROR)
            }
        }
    }

    suspend fun startLogcat() {
        val serial = adb.deviceSerial
        if (!viewModel.uiState.value.adbIsValid || serial.isBlank()) return
        if (logcatJob?.isActive == true) return

        logcatJob = viewModel.viewModelScope.launch(Dispatchers.IO) {
            val buffer = StringBuilder()
            try {
                val logChannel: ReceiveChannel<String> = adb.adb.execute(
                    request = ChanneledLogcatRequest(modes = listOf(LogcatReadMode.threadtime)),
                    serial = serial,
                    scope = this
                )

                logChannel.consumeEach { chunk ->
                    buffer.append(chunk)
                    while (buffer.contains("\n")) {
                        val index = buffer.indexOf("\n")
                        val line = buffer.substring(0, index).trimEnd('\r', '\n')
                        if (line.isNotBlank()) {
                            viewModel.onLogcatReceived(line)
                        }
                        buffer.delete(0, index + 1)
                    }
                }
            } catch (e: Exception) {
                if (e !is kotlinx.coroutines.CancellationException) {
                    viewModel.log("Logcat", "Stream error: ${e.message}", LogLevel.ERROR)
                }
            } finally {
                buffer.clear()
            }
        }
    }

    fun stopLogcat() {
        logcatJob?.cancel()
        logcatJob = null
    }

    suspend fun observeAdb() {
        // 起動時に依存関係をチェック
        checkDependencies()

        while (currentCoroutineContext().isActive) {
            try {
                withContext(Dispatchers.IO) {
                    adb.startAlone()
                }

                while (currentCoroutineContext().isActive) {
                    delay(1000)
                    if (viewModel.uiState.value.isRunning) continue

                    if (adb.isDeviceInitialised()) {
                        if (!viewModel.uiState.value.adbIsValid) {
                            adbProps = AdbProps(adb.osversion, adb.productmodel, adb.deviceSerial, adb.displayId)
                            viewModel.toggleAdbIsValid(true)
                        }
                        adb.adb.execute(ShellCommandRequest("echo"), adb.deviceSerial)
                    }
                }
            } catch (e: Exception) {
                if (viewModel.uiState.value.adbIsValid) {
                    viewModel.toggleAdbIsValid(false)
                    stopLogcat()
                }
                delay(2000)
            }
        }
    }

    suspend fun clearLogcatBuffer() {
        if (!viewModel.uiState.value.adbIsValid) return
        withContext(Dispatchers.IO) {
            adb.adb.execute(ShellCommandRequest("logcat -c"), adb.deviceSerial)
        }
    }
}

File: composeApp/src/jvmMain/kotlin/org/example/project/adb/FastbootClient.kt
package org.example.project.adb

import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import java.io.File
import java.util.concurrent.TimeUnit

data class CommandResult(val exitCode: Int, val output: String)

class FastbootClient {

    // プロジェクトローカルなバイナリを優先、なければシステムパス
    private val executable: String by lazy {
        val local = File("bin/platform-tools/fastboot")
        if (local.exists() && local.canExecute()) local.absolutePath else "fastboot"
    }

    private suspend fun executeCommand(vararg args: String): CommandResult = withContext(Dispatchers.IO) {
        try {
            val process = ProcessBuilder(executable, *args)
                .redirectErrorStream(true)
                .start()

            process.waitFor(30, TimeUnit.SECONDS)
            val output = process.inputStream.bufferedReader().readText()

            CommandResult(process.exitValue(), output.trim())
        } catch (e: Exception) {
            CommandResult(-1, e.message ?: "Unknown error")
        }
    }

    suspend fun getDevices(): List<String> {
        val result = executeCommand("devices")
        if (result.exitCode == 0) {
            return result.output.lines().filter { it.isNotBlank() }.map { it.split("\\s+".toRegex()).first() }
        }
        return emptyList()
    }

    suspend fun flashPartition(serial: String, partition: String, imageFile: File): CommandResult {
        if (!imageFile.exists()) {
            return CommandResult(-1, "Image file not found: ${imageFile.absolutePath}")
        }
        return executeCommand("-s", serial, "flash", partition, imageFile.absolutePath)
    }

    suspend fun reboot(serial: String): CommandResult {
        return executeCommand("-s", serial, "reboot")
    }
}