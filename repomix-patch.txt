File: composeApp/src/jvmMain/kotlin/org/example/project/adb/AdbObserver.kt
package org.example.project.adb

import androidx.lifecycle.viewModelScope
import com.malinskiy.adam.exception.RequestRejectedException
import com.malinskiy.adam.request.misc.RebootMode
import com.malinskiy.adam.request.misc.RebootRequest
import com.malinskiy.adam.request.shell.v1.ShellCommandRequest
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.currentCoroutineContext
import kotlinx.coroutines.delay
import kotlinx.coroutines.isActive
import kotlinx.coroutines.withContext
import org.example.project.AppViewModel
import org.example.project.LogLevel
import org.example.project.adb.rules.AdbDeviceRule
import java.io.File
import java.time.LocalDateTime
import java.time.format.DateTimeFormatter
import com.malinskiy.adam.request.sync.v1.PullFileRequest
import kotlinx.coroutines.channels.consumeEach
import kotlinx.coroutines.Job
import kotlinx.coroutines.launch
import kotlinx.coroutines.channels.ReceiveChannel

class AdbObserver(private val viewModel: AppViewModel) {

    var adb: AdbDeviceRule = AdbDeviceRule()
    var adbProps: AdbProps = AdbProps()
    private var logcatJob: Job? = null

    /**
     * スクリーンショットを撮影し、ローカルに保存します。
     */
    suspend fun captureScreenshot() {
        if (!viewModel.uiState.value.adbIsValid) {
            viewModel.log("ADB", "Cannot take screenshot: No device connected.", LogLevel.ERROR)
            return
        }

        withContext(Dispatchers.IO) {
            try {
                viewModel.log("ADB", "Taking screenshot...", LogLevel.INFO)
                val serial = adb.deviceSerial
                val timestamp = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyyMMdd_HHmmss"))
                val remotePath = "/sdcard/screenshot_tmp.png"

                val localDir = File("screenshots")
                if (!localDir.exists()) localDir.mkdirs()
                val localFile = File(localDir, "screenshot_$timestamp.png")

                // デバイス側でキャプチャ
                adb.adb.execute(ShellCommandRequest("screencap -p $remotePath"), serial)

                // PCへ転送
                val channel = adb.adb.execute(
                    PullFileRequest(remotePath, localFile),
                    this,
                    serial
                )
                for (progress in channel) { /* 進行状況は必要に応じて処理 */ }

                // ゴミ掃除
                adb.adb.execute(ShellCommandRequest("rm $remotePath"), serial)
                viewModel.log("ADB", "Screenshot saved: ${localFile.absolutePath}", LogLevel.PASS)
            } catch (e: Exception) {
                viewModel.log("ADB", "Screenshot failed: ${e.message}", LogLevel.ERROR)
            }
        }
    }

    /**
     * デバイスにテキストを送信します。
     */
    suspend fun sendText(text: String) {
        if (!viewModel.uiState.value.adbIsValid) return
        withContext(Dispatchers.IO) {
            try {
                val escapedText = text.replace(" ", "%s")
                val command = "input text $escapedText"
                val result = adb.adb.execute(ShellCommandRequest(command), adb.deviceSerial)
                if (result.exitCode == 0) {
                    viewModel.log("ADB", "Text sent successfully: $text", LogLevel.PASS)
                } else {
                    viewModel.log("ADB", "Input Failed: ${result.output}", LogLevel.ERROR)
                }
            } catch (e: Exception) {
                viewModel.log("ADB", "Exception sending text: ${e.message}", LogLevel.ERROR)
            }
        }
    }

    /**
     * アプリデータを消去します。
     */
    suspend fun clearAppData(packageName: String) {
        if (!viewModel.uiState.value.adbIsValid) return
        try {
            val output = adb.adb.execute(ShellCommandRequest("pm clear $packageName"), adb.deviceSerial)
            if (output.output.contains("Success")) {
                viewModel.log("ADB", "Cleared app data for $packageName", LogLevel.INFO)
            }
        } catch (e: Exception) {
            viewModel.log("ADB", "Clear data failed: ${e.message}", LogLevel.ERROR)
        }
    }

    /**
     * ブートローダーモードで再起動します。
     */
    suspend fun rebootToBootloader() {
        if (!viewModel.uiState.value.adbIsValid) return
        withContext(Dispatchers.IO) {
            try {
                adb.adb.execute(RebootRequest(RebootMode.BOOTLOADER), adb.deviceSerial)
                viewModel.log("ADB", "Rebooting to bootloader...", LogLevel.PASS)
            } catch (e: Exception) {
                viewModel.log("ADB", "Reboot failed: ${e.message}", LogLevel.ERROR)
            }
        }
    }

    /**
     * キーイベントを送信します。
     */
    suspend fun sendKeyEvent(keyCode: Int) {
        if (!viewModel.uiState.value.adbIsValid) return
        withContext(Dispatchers.IO) {
            try {
                adb.adb.execute(ShellCommandRequest("input keyevent $keyCode"), adb.deviceSerial)
            } catch (e: Exception) {
                viewModel.log("ADB", "Key event failed: ${e.message}", LogLevel.ERROR)
            }
        }
    }

    /**
     * Logcatのストリーミングを開始します。
     * StringBuilderを使用してチャンクを結合し、改行ごとに分割してViewModelへ渡します。
     */
    suspend fun startLogcat() {
        val serial = adb.deviceSerial
        if (!viewModel.uiState.value.adbIsValid || serial.isBlank()) return
        
        if (logcatJob?.isActive == true) return

        logcatJob = viewModel.viewModelScope.launch(Dispatchers.IO) {
            val buffer = StringBuilder()
            try {
                val logChannel: ReceiveChannel<String> = adb.adb.execute(
                    request = ShellCommandRequest("logcat -v time"),
                    serial = serial,
                    scope = this
                )

                logChannel.consumeEach { chunk ->
                    buffer.append(chunk)
                    while (buffer.contains("\n")) {
                        val index = buffer.indexOf("\n")
                        val line = buffer.substring(0, index).trimEnd('\r', '\n')
                        if (line.isNotBlank()) {
                            viewModel.onLogcatReceived(line)
                        }
                        buffer.delete(0, index + 1)
                    }
                }
            } catch (e: Exception) {
                if (e !is kotlinx.coroutines.CancellationException) {
                    viewModel.log("Logcat", "Stream error: ${e.message}", LogLevel.ERROR)
                }
            } finally {
                buffer.clear()
            }
        }
    }

    /**
     * Logcatのストリーミングを停止します。
     */
    fun stopLogcat() {
        logcatJob?.cancel()
        logcatJob = null
    }

    /**
     * ADBデバイスの接続状態を監視し、自動再接続を行います。
     */
    suspend fun observeAdb() {
        while (currentCoroutineContext().isActive) {
            try {
                withContext(Dispatchers.IO) {
                    adb.startAlone()
                }

                while (currentCoroutineContext().isActive) {
                    delay(1000)
                    if (viewModel.uiState.value.isRunning) continue

                    if (adb.isDeviceInitialised()) {
                        if (!viewModel.uiState.value.adbIsValid) {
                            adbProps = AdbProps(adb.osversion, adb.productmodel, adb.deviceSerial, adb.displayId)
                            viewModel.toggleAdbIsValid(true)
                        }
                        adb.adb.execute(ShellCommandRequest("echo"), adb.deviceSerial)
                    }
                }
            } catch (e: Exception) {
                if (viewModel.uiState.value.adbIsValid) {
                    viewModel.toggleAdbIsValid(false)
                    stopLogcat()
                }
                delay(2000)
            }
        }
    }

    /**
     * デバイス側のLogcatバッファをクリアします。
     */
    suspend fun clearLogcatBuffer() {
        if (!viewModel.uiState.value.adbIsValid) return
        withContext(Dispatchers.IO) {
            adb.adb.execute(ShellCommandRequest("logcat -c"), adb.deviceSerial)
        }
    }
}

File: composeApp/src/jvmMain/kotlin/org/example/project/AppViewModel.kt
package org.example.project

import java.time.LocalTime
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.asSharedFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import org.example.project.adb.AdbObserver
import org.example.project.adb.FastbootClient
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.delay
import java.io.File
import androidx.compose.runtime.mutableStateListOf
import kotlinx.coroutines.withContext
import java.io.IOException

class AppViewModel : ViewModel() {
    private val _uiState = MutableStateFlow(AppUiState())
    val uiState = _uiState.asStateFlow()

    private val _logFlow = MutableSharedFlow<LogLine>(replay = 100)
    val logFlow = _logFlow.asSharedFlow()

    private val _isLogcatWindowOpen = MutableStateFlow(false)
    val isLogcatWindowOpen = _isLogcatWindowOpen.asStateFlow()

    private val _logcatLines = mutableStateListOf<LogLine>()
    val logcatLines: List<LogLine> get() = _logcatLines

    private val _logcatFilter = MutableStateFlow("")
    val logcatFilter = _logcatFilter.asStateFlow()

    private val adbObserver = AdbObserver(this)
    private val fastbootClient = FastbootClient()

    private val RAW_LOGCAT_FILE = File("raw_logcat_output.log")

    init {
        startAdbObservation()
    }

    fun pressHome() = viewModelScope.launch { adbObserver.sendKeyEvent(3) }
    fun pressBack() = viewModelScope.launch { adbObserver.sendKeyEvent(4) }
    fun pressEnter() = viewModelScope.launch { adbObserver.sendKeyEvent(66) }

    private fun startAdbObservation() {
        viewModelScope.launch {
            try {
                adbObserver.observeAdb()
            } catch (e: Exception) {
                log("ADB", "Observer error: ${e.message}", LogLevel.ERROR)
            }
        }
    }

    fun toggleAdbIsValid(isValid: Boolean) {
        _uiState.update { it.copy(adbIsValid = isValid) }
        log("ADB", "Status: ${if (isValid) "Connected" else "Disconnected"}", if (isValid) LogLevel.PASS else LogLevel.ERROR)
    }

    fun setRunning(isRunning: Boolean) {
        _uiState.update { it.copy(isRunning = isRunning) }
    }

    fun log(tag: String, message: String, level: LogLevel = LogLevel.INFO) {
        val timestamp = LocalTime.now().toString().take(8)
        viewModelScope.launch {
            _logFlow.emit(LogLine(timestamp, tag, message, level))
        }
    }

    fun captureScreenshot() {
        viewModelScope.launch { adbObserver.captureScreenshot() }
    }

    fun sendText(text: String) {
        viewModelScope.launch { adbObserver.sendText(text) }
    }

    fun clearAppData() {
        viewModelScope.launch { adbObserver.clearAppData("org.example.project") }
    }

    fun openLogcatWindow() {
        _isLogcatWindowOpen.value = true
        startLogcat()
    }

    fun closeLogcatWindow() {
        _isLogcatWindowOpen.value = false
        stopLogcat()
    }

    fun startLogcat() {
        viewModelScope.launch {
            adbObserver.startLogcat()
        }
    }

    fun stopLogcat() {
        adbObserver.stopLogcat()
    }

    fun clearLogcat() {
        _logcatLines.clear()
        viewModelScope.launch { adbObserver.clearLogcatBuffer() }
    }

    fun updateLogcatFilter(text: String) {
        _logcatFilter.value = text
    }

    /**
     * AdbObserverから1行ずつログを受け取り、パースしてUI用リストに追加します。
     */
    fun onLogcatReceived(rawLine: String) {
        writeRawLogcatToFile(rawLine)
        val parsedLog = parseLogLine(rawLine) ?: LogLine("", "RAW", rawLine, LogLevel.INFO)
        
        _logcatLines.add(parsedLog)
        if (_logcatLines.size > 2000) _logcatLines.removeAt(0)
    }

    /**
     * ログ行を簡易的にパースします。
     */
    private fun parseLogLine(line: String): LogLine? {
        val parts = line.trim().split(Regex("\\s+"))
        if (parts.size < 5) return null
        
        val timestamp = "${parts[0]} ${parts[1]}"
        val levelStr = parts[4]
        val level = when (levelStr) {
            "E", "F" -> LogLevel.ERROR
            "W" -> LogLevel.WARN
            "D", "V" -> LogLevel.DEBUG
            else -> LogLevel.INFO
        }
        
        val body = line.substringAfter(levelStr).trim()
        val tag = body.substringBefore(":").trim()
        val message = body.substringAfter(":").trim()

        return LogLine(timestamp, tag, message, level)
    }

    /**
     * 生のログをデバッグ用にファイル保存します。
     */
    private fun writeRawLogcatToFile(line: String) {
        viewModelScope.launch(Dispatchers.IO) {
            try {
                RAW_LOGCAT_FILE.appendText(line + "\n")
            } catch (e: IOException) {}
        }
    }
}